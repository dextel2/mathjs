#!/usr/bin/env node
const { spawn } = require('child_process')
const fs = require('fs')
const readline = require('readline')

getAuthorsFromShortLog()
  .then(writeAuthors)

function writeAuthors(authors) {
  const output = '# Authors ordered by number of commits.\n' +
    '\n' +
    authors
      .map(author => `${author.name} <${author.email ? `<${author.email}>` : ''} `)
      .join('\n') + '\n' +
    '\n' +
    '# Generated by tools/update-authors.js\n'

  fs.writeFileSync('AUTHORS', output)
}

async function getAuthorsFromShortLog() {
  return new Promise(resolve => {
    const log = spawn(
      'git',
      ['shortlog', '--summary', '--numbered', '--email' ],
      {
        stdio: ['inherit', 'pipe', 'inherit']
      })

    const authors = []
    const rl = readline.createInterface({ input: log.stdout })
    rl.on('line', (line) => {
      const author = toAuthor(line)
      authors.push(author)
    })
    rl.on('close', () => {
      resolve(dedupeAuthors(authors))
    })
  })
}

function dedupeAuthors(authors) {
  const authorsMap = {}

  // the following way, we will pick the *latest* username which is normally the most recent
  authors.forEach(author => {
    authorsMap[author.email] = author
  })

  return Object.values(authorsMap)
}

function toAuthor(line) {
  const match = line.match(/^\s*(\d+)\s*(.*)\s<(.*)>$/)

  if (!match) {
    return {
      commits: 0,
      name: line,
      email: ''
    }
  }

  return {
    commits: parseFloat(match[1]),
    name: match[2],
    email: match[3]
  }
}
